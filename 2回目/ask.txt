> 添付のex1.cについて
> char *str;
> scanfで取ってきた文字列の先頭アドレスをポインタsに格納してprintfをする
際
> に，printf("%s",*str);にすると，エラーを起こします．
> 書式的には値を入れると書いてあるのですが，なぜ*strはダメでアドレスであ
る
> strは実行できるのでしょうか．

なぜ*strはダメでアドレスであるstrは実行できるのかというと、strが指す先の
メモリ領域が確保できていないからです。
メモリが確保できていない状態で間接参照演算子*で中身にアクセスしようとす
ると、terminated by signal SIGSEGV (Address boundary errorが発生します。
要は、ポインタの指し示す先が指定されていないのに中身を見ようとしたから怒
られた、ということですね。

添付してくれたex1.cは少し複雑なので、以下のシンプルな例を考えましょう。
------------------------
#include <stdio.h>
int main(){
        char *s;           // ①
  scanf("%s", s);    // ②
  printf("%s", s);   // ③
}
------------------------
①では、char型のポインタsを宣言しています。このとき、スタック領域にアドレ
スを入れるための8byteのメモリ領域が確保されます。
ここで注意して欲しいのですが、これだけでは、文字列を入れるためのメモリ領
域は確保されていません。単に、アドレスを入れるためのメモリ領域が確保され
ただけです。
この状態で②を実行すると、何が起こるかは未定義です。今回は場合は何も起き
ず書き込まれないだけのようです。

scanfというのは、第２引数で指定したアドレスにキーボード入力を書き込む関
数です。
しかし、②の時点では、char型のポインタsはまだどこも指していません（言い換
えれば、どこのアドレスも代入されていません。）
その結果、scanfはどこにキーボード入力を書き込んでよいかわからず終了しま
す。

最後に③について、printfの書式で%sを使う場合、それに対応する引数は、char
型のポインタでなければなりません。
コンパイルエラーにはなりませんが、Warningがでます。printf("%s", *s)とす
ると、
warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 
has type ‘int’
のようなメッセージが出ます。このメッセージは、「%sなのに、第２引数にchar 
*じゃなくてintがきてます」という意味です。

さて、上記の問題に対する解決は２つあります。

【解１】文字列を入れるためのメモリ領域を確保する。
------------------------
#include <stdio.h>
#include <stdlib.h>
int main(){
        char *s = malloc(100); // ①
  scanf("%s", s);        // ②
  printf("%s", s);       // ③
}
------------------------
mallocは授業で説明していない関数です。引数で指定したbyte数、ヒープ領域に
メモリを確保し、そのアドレスを返します。
①の場合だと、ヒープ領域に100byte確保し、その確保したメモリ領域のアドレス
をchar型のポインタsに代入しています。
これで、sはヒープ領域に確保されたメモリを指し示すようになります。
②では、sの指し示す先、すなわちヒープ領域に確保された100byteのメモリ領域
にキーボードの入力を書き込みます。
③では、sの指し示す先の文字列、すなわちヒープ領域に確保された100byteのメ
モリ領域の先頭アドレスから終端記号までを表示します。

【解2】配列にする。
------------------------
#include <stdio.h>
#include <stdlib.h>
int main(){
        char s[100];      // ①
  scanf("%s", s);   // ②
  printf("%s", s);  // ③
}
------------------------
①のように配列を使うと、スタック領域に100byte確保されます。
②では、s（配列の先頭アドレス）、すなわちスタック領域に確保された100byte
のメモリ領域にキーボードの入力を書き込みます。
③では、s（配列の先頭アドレス）、すなわちスタック領域に確保された100byte
のメモリ領域の先頭アドレスから終端記号までを表示します。


> 添付のex2.cについて
> char s[256];
> 1.scanfの書式では引数に変数のアドレスを取ると書いてあるのですが，scanf
("%
> s",&s)とscanf("%s",s)両方実行できてしまいます．
> scanf("%s",&s)はアドレスを引数にしているが，
>  warning: format specifies type 'char *' but the argument has type
>       'char (*)[256]' [-Wformat]
>         while((scanf("%s",&s))&& s != EOF){
> というwarningが出てしまいます．
> 何故なのでしょうか

まず、「scanf("%s",&s)とscanf("%s",s)両方実行できてしまいます．」という
ことについては、&sもsもアドレスだからです。
配列は、添字を除いた名前だけを記述した時、その配列の最初の要素のアドレス
を意味します。
&はアドレス演算子といいます。変数のアドレスを得るための演算子です。
次のコードを書いて実行結果を確認してみてください。
------------------------
#include <stdio.h>
int main(){
        char s[256];
  printf("s    =%p¥n", s);      // ①
  printf("&s[0]=%p¥n", &s[0]);  // ②
  printf("&s   =%p¥n", &s);     // ③
}
------------------------
①は配列の先頭の要素のアドレスです。
②は配列の先頭の要素のアドレスです。
③は配列そのものアドレスです。結局先頭のアドレスです。
これらは、全部、同じアドレスを指します。
ただし、型は異なります。①と②はchar型のポインタ(char *)ですが、③はchar型
の配列のポインタ(char (*)[256])となります。

scanf("%s", &s)でwarningが出るのは、%sは対応する引数にchar型のポインタ(
char *)を要求するのに対し、&sはchar型の配列のポインタ(char (*)[256])で、
型が異なるためです。


> 2.次の講義で,もし課題の解答がscanfを用いないのであれば，scanfで終端文
字
> を見つけてwhileを止めたい時の賢い止め方を教えて欲しいです．

これは、残念ながらあまり賢いやり方はありません。素直にfgetsのやり方を使
うほうが良いと想います。
どうしてもscanfを使うということでしたら、scanfの返り値が-1 (=EOF)かどう
かで判断するのがいいかと思います。
ちなみにファイル入力の場合は、fscanf関数を使います。その場合は、
------------------------
#include <stdio.h>
int main(){
  FILE *fp = fopen("filename", "r");
  char s[100];
  int ret = 0;
  while (fscanf(fp, "%s", s) != EOF) {
      printf("%s¥n", s);
  }
  fclose(fp);
}
------------------------
こんな感じですかね。
しかしながら、やはりfgetsのほうがおすすめです。

> 3.scanfは，空白で区切った後に，もう一度scanfすると自動で次の文字の最初
か
> ら読み取るという認識であっていますか？
> ex
> abcd efgh
> abcd(scanf一回目) efgh(scanf二回目)

そうですね。その認識だってます。
空白は無視されてその次からです。

以上です。

飯尾

----- Original Message -----
> 理工学部情報システムデザイン学科３回生の栗栖と申します．
> 今回の講義ではポインタについてとてもわかりやすく，今までおまじないで書
い
> ていたところがとても理解できました．
> 今回の課題をしている時にでてきたエラーに関して質問なのですが，
> 
> 添付のex1.cについて
> char *str;
> scanfで取ってきた文字列の先頭アドレスをポインタsに格納してprintfをする
際
> に，printf("%s",*str);にすると，エラーを起こします．
> 書式的には値を入れると書いてあるのですが，なぜ*strはダメでアドレスであ
る
> strは実行できるのでしょうか．
> 
> 添付のex2.cについて
> char s[256];
> 1.scanfの書式では引数に変数のアドレスを取ると書いてあるのですが，scanf
("%
> s",&s)とscanf("%s",s)両方実行できてしまいます．
> scanf("%s",&s)はアドレスを引数にしているが，
>  warning: format specifies type 'char *' but the argument has type
>       'char (*)[256]' [-Wformat]
>         while((scanf("%s",&s))&& s != EOF){
> というwarningが出てしまいます．
> 何故なのでしょうか
> 
> 2.次の講義で,もし課題の解答がscanfを用いないのであれば，scanfで終端文
字
> を見つけてwhileを止めたい時の賢い止め方を教えて欲しいです．
> 
> 3.scanfは，空白で区切った後に，もう一度scanfすると自動で次の文字の最初
か
> ら読み取るという認識であっていますか？
> ex
> abcd efgh
> abcd(scanf一回目) efgh(scanf二回目